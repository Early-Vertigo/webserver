## 功能
* 利用IO复用技术Epoll与线程池实现多线程的Reactor高并发模型；
* 利用正则与状态机解析HTTP请求报文，实现处理静态资源的请求；
* 利用标准库容器封装char，实现自动增长的缓冲区；
* 基于小根堆实现的定时器，关闭超时的非活动连接；
* 利用单例模式与阻塞队列实现异步的日志系统，记录服务器运行状态；
    日志写是需要调用IO的，IO密集需要避免同步，否则降低性能，所以采用异步
    同步日志是在主线程中主动运行，会影响后续业务逻辑的运行
    异步日志是将日志将给子线程处理，不影响后续业务逻辑的运行
* 利用RAII机制实现了数据库连接池，减少数据库连接建立与关闭的开销，同时实现了用户注册登录功能。

    EpollOneshot
        一个连接的数据被不同的工作线程处理
            即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个
            问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该
            socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于
            是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可
            以使用 epoll 的 EPOLLONESHOT 事件实现。

            对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异
            常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事
            件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思
            考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个
            socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进
            而让其他工作线程有机会继续处理这个 socket。

* webbench
    webbench -c 5000 -t 5 http://127.0.0.1:1316/

    返回结果

    如果再重新执行程序，会发现
    netstat -anp | grep
    会发现许多tcp连接处于time_wait状态，端口被占用
    可以通过设置端口复用解决